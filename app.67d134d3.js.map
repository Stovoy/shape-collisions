{"version":3,"sources":["app.js"],"names":["numberOfShapes","drawQuadTree","drawBoundingBoxes","Line","p1","p2","Point","x","y","Shape","id","points","color","xVel","yVel","baseBoundingBox","calcBoundingBox","recalcBoundingBox","ctx","collides","beginPath","moveTo","i","length","point","lineTo","strokeStyle","fillStyle","stroke","fill","strokeRect","boundingBox","width","height","lines","nextPoint","push","x1","y1","x2","y2","Rectangle","other","calcLines","line","lineCollision","pointInRectangle","center","rectangleCollision","QuadTree","root","QuadNode","capacity","shape","insertInto","node","shapes","subdivided","subdivideNode","insertIntoThisNode","nw","ne","sw","se","halfWidth","halfHeight","oldShapes","collisionsFrom","queryShape","collisions","concat","draw","onSegment","p","q","r","Math","max","min","orientation","v","l1","l2","o1","o2","o3","o4","r1","r2","start","canvas","document","getElementById","getContext","colors","j","floor","random","fillRect","quadtree","insert","collisionIds","Set","has","collision","add","setInterval","move"],"mappings":"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","file":"app.67d134d3.js","sourceRoot":"..","sourcesContent":["const numberOfShapes = 50;\nconst drawQuadTree = false;\nconst drawBoundingBoxes = false;\n\nclass Line {\n    constructor(p1, p2) {\n        this.p1 = p1;\n        this.p2 = p2;\n    }\n}\n\nclass Point {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n}\n\nclass Shape {\n    constructor(id, points, x, y, color) {\n        this.id = id;\n        this.points = points;\n        this.x = x;\n        this.y = y;\n        this.color = color;\n        this.xVel = 0;\n        this.yVel = 0;\n        this.baseBoundingBox = this.calcBoundingBox();\n        this.recalcBoundingBox();\n    }\n\n    draw(ctx, collides) {\n        ctx.beginPath();\n        ctx.moveTo(this.points[0].x + this.x, this.points[0].y + this.y);\n        for (let i = 1; i < this.points.length; i++) {\n            const point = this.points[i];\n            ctx.lineTo(point.x + this.x, point.y + this.y);\n        }\n        ctx.lineTo(this.points[0].x + this.x, this.points[0].y + this.y);\n        ctx.strokeStyle = 'black';\n        if (collides) {\n            ctx.fillStyle = 'red';\n        } else {\n            ctx.fillStyle = this.color;\n        }\n        ctx.stroke();\n        ctx.fill();\n\n        if (drawBoundingBoxes) {\n            ctx.strokeStyle = 'purple';\n            ctx.strokeRect(this.boundingBox.x, this.boundingBox.y, this.boundingBox.width, this.boundingBox.height);\n        }\n    }\n\n    calcLines() {\n        const lines = [];\n        for (let i = 0; i < this.points.length; i++) {\n            const point = this.points[i];\n            let nextPoint;\n            if (i === this.points.length - 1) {\n                nextPoint = this.points[0];\n            } else {\n                nextPoint = this.points[i + 1];\n            }\n            lines.push(new Line(\n                new Point(point.x + this.x, point.y + this.y),\n                new Point(nextPoint.x + this.x, nextPoint.y + this.y)));\n        }\n        return lines;\n    }\n\n    calcBoundingBox() {\n        let x1 = null;\n        let y1 = null;\n        let x2 = 0;\n        let y2 = 0;\n        for (let point of this.points) {\n            if (x1 == null || point.x < x1) {\n                x1 = point.x;\n            }\n            if (y1 == null || point.y < y1) {\n                y1 = point.y;\n            }\n            if (point.x > x2) {\n                x2 = point.x;\n            }\n            if (point.y > y2) {\n                y2 = point.y;\n            }\n        }\n        let width = x2 - x1;\n        let height = y2 - y1;\n        return new Rectangle(x1, y1, width, height);\n    }\n\n    recalcBoundingBox() {\n        this.boundingBox = new Rectangle(\n            this.baseBoundingBox.x + this.x,\n            this.baseBoundingBox.y + this.y,\n            this.baseBoundingBox.width,\n            this.baseBoundingBox.height,\n        );\n    }\n\n    collides(other) {\n        // To test intersection, we first check every edge against each other\n        for (let line of this.calcLines()) {\n            for (let otherLine of other.calcLines()) {\n                if (lineCollision(line, otherLine)) {\n                    return true;\n                }\n            }\n        }\n\n        // Then, to test the complete containment edge case, we check to see if center point is in bounding box of other\n        return pointInRectangle(this.boundingBox.center, other.boundingBox);\n    }\n}\n\nclass Rectangle {\n    constructor(x, y, width, height) {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n        this.center = new Point(this.x + this.width / 2, this.y + this.height / 2);\n    }\n\n    collides(other) {\n        return rectangleCollision(this, other);\n    }\n}\n\nclass QuadTree {\n    constructor(x, y, width, height) {\n        this.root = new QuadNode(x, y, width, height);\n        this.capacity = 1;\n    }\n\n    insert(shape) {\n        this.insertInto(this.root, shape);\n    }\n\n    insertInto(node, shape) {\n        if (!shape.boundingBox.collides(node.boundingBox)) {\n            return;\n        }\n\n        if ((node.shapes.length > this.capacity) && !node.subdivided) {\n            this.subdivideNode(node);\n        }\n\n        let insertIntoThisNode = true;\n        if (node.subdivided) {\n            insertIntoThisNode = false;\n            if (shape.boundingBox.collides(node.nw.boundingBox)) {\n                if (shape.boundingBox.collides(node.ne.boundingBox) ||\n                    shape.boundingBox.collides(node.sw.boundingBox) ||\n                    shape.boundingBox.collides(node.se.boundingBox)) {\n                    insertIntoThisNode = true;\n                } else {\n                    this.insertInto(node.nw, shape);\n                }\n            } else if (shape.boundingBox.collides(node.ne.boundingBox)) {\n                if (shape.boundingBox.collides(node.sw.boundingBox) ||\n                    shape.boundingBox.collides(node.se.boundingBox)) {\n                    insertIntoThisNode = true;\n                } else {\n                    this.insertInto(node.ne, shape);\n                }\n            } else if (shape.boundingBox.collides(node.sw.boundingBox)) {\n                if (shape.boundingBox.collides(node.se.boundingBox)) {\n                    insertIntoThisNode = true;\n                } else {\n                    this.insertInto(node.sw, shape);\n                }\n            } else if (shape.boundingBox.collides(node.se.boundingBox)) {\n                this.insertInto(node.se, shape);\n            }\n        }\n\n        if (insertIntoThisNode) {\n            node.shapes.push(shape);\n        }\n    }\n\n    subdivideNode(node) {\n        let halfWidth = node.boundingBox.width / 2;\n        let halfHeight = node.boundingBox.height / 2;\n        node.nw = new QuadNode(node.boundingBox.x, node.boundingBox.y, halfWidth, halfHeight);\n        node.ne = new QuadNode(node.boundingBox.x + halfWidth, node.boundingBox.y, halfWidth, halfHeight);\n        node.sw = new QuadNode(node.boundingBox.x, node.boundingBox.y + halfHeight, halfWidth, halfHeight);\n        node.se = new QuadNode(node.boundingBox.x + halfWidth, node.boundingBox.y + halfHeight, halfWidth, halfHeight);\n        node.subdivided = true;\n\n        let oldShapes = node.shapes;\n        node.shapes = [];\n\n        for (let shape of oldShapes) {\n            this.insertInto(node, shape);\n        }\n    }\n\n    collisions(shape) {\n        return this.collisionsFrom(this.root, shape);\n    }\n\n    collisionsFrom(node, queryShape) {\n        let collisions = [];\n        for (const shape of node.shapes) {\n            if (queryShape.id === shape.id) {\n                continue;\n            }\n            if (queryShape.collides(shape)) {\n                collisions.push(shape);\n            }\n        }\n\n        if (node.subdivided) {\n            if (queryShape.boundingBox.collides(node.nw.boundingBox)) {\n                collisions = collisions.concat(this.collisionsFrom(node.nw, queryShape));\n            }\n            if (queryShape.boundingBox.collides(node.ne.boundingBox)) {\n                collisions = collisions.concat(this.collisionsFrom(node.ne, queryShape));\n            }\n            if (queryShape.boundingBox.collides(node.sw.boundingBox)) {\n                collisions = collisions.concat(this.collisionsFrom(node.sw, queryShape));\n            }\n            if (queryShape.boundingBox.collides(node.se.boundingBox)) {\n                collisions = collisions.concat(this.collisionsFrom(node.se, queryShape));\n            }\n        }\n        return collisions;\n    }\n\n    draw(ctx, node) {\n        ctx.strokeStyle = 'black';\n        ctx.strokeRect(node.boundingBox.x, node.boundingBox.y, node.boundingBox.width, node.boundingBox.height);\n        if (node.subdivided) {\n            this.draw(ctx, node.nw);\n            this.draw(ctx, node.ne);\n            this.draw(ctx, node.sw);\n            this.draw(ctx, node.se);\n        }\n    }\n}\n\nclass QuadNode {\n    constructor(x, y, width, height) {\n        this.shapes = [];\n        this.boundingBox = new Rectangle(x, y, width, height);\n        this.nw = null;\n        this.ne = null;\n        this.sw = null;\n        this.se = null;\n        this.subdivided = false;\n    }\n}\n\n// Given three colinear points p, q, r, the function checks if\n// point q lies on line segment 'pr'\nfunction onSegment(p, q, r) {\n    return q.x <= Math.max(p.x, r.x) &&\n        q.x >= Math.min(p.x, r.x) &&\n        q.y <= Math.max(p.y, r.y) &&\n        q.y >= Math.min(p.y, r.y);\n}\n\n// Finds the orientation of an ordered triplet (p,q,r)\n// Returns the following values:\n// 0 : Colinear points\n// 1 : Clockwise points\n// 2 : Counterclockwise\nfunction orientation(p, q, r) {\n    const v = (q.y - p.y) * (r.x - q.x) -\n        (q.x - p.x) * (r.y - q.y);\n    if (v > 0) {\n        return 1;\n    } else if (v < 0) {\n        return 2;\n    } else {\n        return 0;\n    }\n}\n\nfunction lineCollision(l1, l2) {\n    const o1 = orientation(l1.p1, l1.p2, l2.p1);\n    const o2 = orientation(l1.p1, l1.p2, l2.p2);\n    const o3 = orientation(l2.p1, l2.p2, l1.p1);\n    const o4 = orientation(l2.p1, l2.p2, l1.p2);\n    if (o1 !== o2 && o3 !== o4) {\n        return true;\n    }\n    // l1.p1, l1.p2, l2.p1 are colinear and l2.p1 lies on l1.\n    if (o1 === 0 && onSegment(l1.p1, l2.p1, l1.p2)) {\n        return true;\n    }\n\n    // l1.p1, l1.p2, l2.p2 are colinear and l2.p2 lies on l1.\n    if (o2 === 0 && onSegment(l1.p1, l2.p2, l1.p2)) {\n        return true;\n    }\n\n    // l2.p1, l2.p2, l1.p1 are colinear and l1.p1 lies on l2.\n    if (o3 === 0 && onSegment(l2.p1, l1.p1, l2.p2)) {\n        return true;\n    }\n\n    // l2.p1, l2.p2, l1.p2 are colinear and l1.p2 lies on l2.\n    return o4 === 0 && onSegment(l2.p1, l1.p2, l2.p2);\n}\n\nfunction rectangleCollision(r1, r2) {\n    return r1.x < r2.x + r2.width &&\n        r1.x + r1.width > r2.x &&\n        r1.y < r2.y + r2.height &&\n        r1.y + r1.height > r2.y;\n}\n\nfunction pointInRectangle(p, r) {\n    return p.x > r.x &&\n        p.x < r.x + r.width &&\n        p.y > r.y &&\n        p.y < r.y + r.height;\n}\n\nfunction start() {\n    const canvas = document.getElementById(\"canvas\");\n    const ctx = canvas.getContext(\"2d\");\n    const shapes = [];\n    const colors = ['blue', 'purple', 'pink', 'orange', 'black', 'green'];\n    const width = 800;\n    const height = 800;\n\n    for (let i = 0; i < numberOfShapes; i++) {\n        let points = [];\n        for (let j = 0; j < Math.floor(Math.random() * 20) + 1; j++) {\n            points.push(new Point(\n                Math.random() * 100,\n                Math.random() * 100,\n            ));\n        }\n        shapes.push(\n            new Shape(i, points,\n                Math.random() * 400,\n                Math.random() * 400,\n                colors[Math.floor(Math.random() * colors.length)])\n        );\n    }\n\n    function draw() {\n        ctx.fillStyle = 'white';\n        ctx.fillRect(0, 0, width, height);\n        const quadtree = new QuadTree(0, 0, width, height);\n        for (let shape of shapes) {\n            shape.recalcBoundingBox();\n            quadtree.insert(shape);\n        }\n\n        if (drawQuadTree) {\n            quadtree.draw(ctx, quadtree.root);\n        }\n\n        const collisionIds = new Set();\n        for (let shape of shapes) {\n            if (collisionIds.has(shape.id)) {\n                continue;\n            }\n            let collisions = quadtree.collisions(shape);\n            for (let collision of collisions) {\n                collisionIds.add(collision.id);\n            }\n            if (collisions.length > 0) {\n                collisionIds.add(shape.id);\n            }\n        }\n\n        for (let shape of shapes) {\n            if (collisionIds.has(shape.id)) {\n                shape.draw(ctx, true);\n            } else {\n                shape.draw(ctx);\n            }\n        }\n    }\n\n    function move() {\n        for (let shape of shapes) {\n            shape.xVel += (Math.random() - 0.5) * 2;\n            shape.yVel += (Math.random() - 0.5) * 2;\n            shape.x += shape.xVel;\n            shape.y += shape.yVel;\n            if (shape.x < 0) {\n                shape.x = 0;\n                shape.xVel = 0;\n            }\n            if (shape.y < 0) {\n                shape.y = 0;\n                shape.yVel = 0;\n            }\n            if (shape.x > width) {\n                shape.x = width;\n                shape.xVel = 0;\n            }\n            if (shape.y > height) {\n                shape.y = height;\n                shape.yVel = 0;\n            }\n        }\n    }\n\n    draw();\n\n    setInterval(() => {\n        move();\n        draw();\n    }, 50);\n}\n\nstart();\n"]}