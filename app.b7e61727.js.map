{"version":3,"sources":["app.js"],"names":["numberOfShapes","minNumberOfSides","sideNumberVarience","maxShapeWidth","maxShapeHeight","drawQuadTree","drawBoundingBoxes","hideColliding","hideNonColliding","numberOfShapesElement","document","getElementById","minNumberOfSidesElement","sideNumberVarienceElement","maxShapeWidthElement","maxShapeHeightElement","drawQuadTreeElement","drawBoundingBoxesElement","hideCollidingElement","hideNonCollidingElement","value","oninput","onchange","generateShapes","onclick","checked","Line","p1","p2","Point","x","y","Shape","id","points","color","xVel","yVel","baseBoundingBox","calcBoundingBox","recalcBoundingBox","ctx","collides","beginPath","moveTo","i","length","point","lineTo","strokeStyle","fillStyle","stroke","fill","strokeRect","boundingBox","width","height","lines","nextPoint","push","x1","y1","x2","y2","Rectangle","other","calcLines","line","lineCollision","pointInRectangle","center","rectangleCollision","QuadTree","root","QuadNode","capacity","shape","insertInto","node","shapes","subdivided","subdivideNode","insertIntoThisNode","nw","ne","sw","se","halfWidth","halfHeight","oldShapes","collisionsFrom","queryShape","collisions","concat","draw","onSegment","p","q","r","Math","max","min","orientation","v","l1","l2","o1","o2","o3","o4","r1","r2","canvas","getContext","colors","j","round","random","floor","fillRect","quadtree","insert","collisionIds","Set","has","collision","add","move","start","setInterval"],"mappings":";AA4eK,SAAA,EAAA,EAAA,GAAA,IAAA,EAAA,GAAA,oBAAA,QAAA,MAAA,EAAA,OAAA,UAAA,CAAA,GAAA,MAAA,QAAA,KAAA,EAAA,EAAA,KAAA,GAAA,GAAA,iBAAA,EAAA,OAAA,CAAA,IAAA,EAAA,GAAA,IAAA,EAAA,EAAA,EAAA,aAAA,MAAA,CAAA,EAAA,EAAA,EAAA,WAAA,OAAA,GAAA,EAAA,OAAA,CAAA,MAAA,GAAA,CAAA,MAAA,EAAA,MAAA,EAAA,OAAA,EAAA,SAAA,GAAA,MAAA,GAAA,EAAA,GAAA,MAAA,IAAA,UAAA,yIAAA,IAAA,EAAA,GAAA,EAAA,GAAA,EAAA,MAAA,CAAA,EAAA,WAAA,EAAA,EAAA,OAAA,aAAA,EAAA,WAAA,IAAA,EAAA,EAAA,OAAA,OAAA,EAAA,EAAA,KAAA,GAAA,EAAA,SAAA,GAAA,GAAA,EAAA,EAAA,GAAA,EAAA,WAAA,IAAA,GAAA,MAAA,EAAA,QAAA,EAAA,SAAA,QAAA,GAAA,EAAA,MAAA,KAAA,SAAA,EAAA,EAAA,GAAA,GAAA,EAAA,CAAA,GAAA,iBAAA,EAAA,OAAA,EAAA,EAAA,GAAA,IAAA,EAAA,OAAA,UAAA,SAAA,KAAA,GAAA,MAAA,GAAA,GAAA,MAAA,WAAA,GAAA,EAAA,cAAA,EAAA,EAAA,YAAA,MAAA,QAAA,GAAA,QAAA,EAAA,MAAA,KAAA,GAAA,cAAA,GAAA,2CAAA,KAAA,GAAA,EAAA,EAAA,QAAA,GAAA,SAAA,EAAA,EAAA,IAAA,MAAA,GAAA,EAAA,EAAA,UAAA,EAAA,EAAA,QAAA,IAAA,IAAA,EAAA,EAAA,EAAA,IAAA,MAAA,GAAA,EAAA,EAAA,IAAA,EAAA,GAAA,EAAA,GAAA,OAAA,EAAA,SAAA,EAAA,EAAA,GAAA,IAAA,IAAA,EAAA,EAAA,EAAA,EAAA,OAAA,IAAA,CAAA,IAAA,EAAA,EAAA,GAAA,EAAA,WAAA,EAAA,aAAA,EAAA,EAAA,cAAA,EAAA,UAAA,IAAA,EAAA,UAAA,GAAA,OAAA,eAAA,EAAA,EAAA,IAAA,IAAA,SAAA,EAAA,EAAA,EAAA,GAAA,OAAA,GAAA,EAAA,EAAA,UAAA,GAAA,GAAA,EAAA,EAAA,GAAA,EAAA,SAAA,EAAA,EAAA,GAAA,KAAA,aAAA,GAAA,MAAA,IAAA,UAAA,qCA5eL,IAAIA,EAAiB,GACjBC,EAAmB,EACnBC,EAAqB,EACrBC,EAAgB,IAChBC,EAAiB,IACjBC,GAAe,EACfC,GAAoB,EACpBC,GAAgB,EAChBC,GAAmB,EAEjBC,EAAwBC,SAASC,eAAe,kBAChDC,EAA0BF,SAASC,eAAe,oBAClDE,EAA4BH,SAASC,eAAe,sBACpDG,EAAuBJ,SAASC,eAAe,iBAC/CI,EAAwBL,SAASC,eAAe,kBAChDK,EAAsBN,SAASC,eAAe,gBAC9CM,EAA2BP,SAASC,eAAe,qBACnDO,EAAuBR,SAASC,eAAe,iBAC/CQ,EAA0BT,SAASC,eAAe,oBAExDF,EAAsBW,MAAQpB,EAC9BS,EAAsBY,QAAQ,MAC9BT,EAAwBQ,MAAQnB,EAChCW,EAAwBS,QAAQ,MAChCR,EAA0BO,MAAQlB,EAClCW,EAA0BQ,QAAQ,MAClCP,EAAqBM,MAAQjB,EAC7BW,EAAqBO,QAAQ,MAC7BN,EAAsBK,MAAQhB,EAC9BW,EAAsBM,QAAQ,MAE9BZ,EAAsBa,SAAW,WAC7BtB,EAAiBS,EAAsBW,MACvCG,KAEJX,EAAwBU,SAAW,WAC/BrB,EAAmBW,EAAwBQ,MAC3CG,KAEJV,EAA0BS,SAAW,WACjCpB,EAAqBW,EAA0BO,MAC/CG,KAEJT,EAAqBQ,SAAW,WAC5BnB,EAAgBW,EAAqBM,MACrCG,KAEJR,EAAsBO,SAAW,WAC7BlB,EAAiBW,EAAsBK,MACvCG,KAEJP,EAAoBQ,QAAU,WAC1BnB,EAAeW,EAAoBS,SAEvCR,EAAyBO,QAAU,WAC/BlB,EAAoBW,EAAyBQ,SAEjDP,EAAqBM,QAAU,WAC3BjB,EAAgBW,EAAqBO,SAEzCN,EAAwBK,QAAU,WAC9BhB,EAAmBW,EAAwBM,SAGzCC,IAAAA,EACF,SAAYC,EAAAA,EAAIC,GAAI,EAAA,KAAA,GACXD,KAAAA,GAAKA,EACLC,KAAAA,GAAKA,GAIZC,EACF,SAAYC,EAAAA,EAAGC,GAAG,EAAA,KAAA,GACTD,KAAAA,EAAIA,EACJC,KAAAA,EAAIA,GAIXC,EAAAA,WACUC,SAAAA,EAAAA,EAAIC,EAAQJ,EAAGC,EAAGI,GAAO,EAAA,KAAA,GAC5BF,KAAAA,GAAKA,EACLC,KAAAA,OAASA,EACTJ,KAAAA,EAAIA,EACJC,KAAAA,EAAIA,EACJI,KAAAA,MAAQA,EACRC,KAAAA,KAAO,EACPC,KAAAA,KAAO,EACPC,KAAAA,gBAAkB,KAAKC,kBACvBC,KAAAA,oBAoZR,OAAA,EAAA,EAAA,CAAA,CAAA,IAAA,OAjZD,MAAA,SAAKC,EAAKC,GACFA,KAAAA,IAAYnC,KAGXmC,IAAYlC,GAAb,CAIJiC,EAAIE,YACJF,EAAIG,OAAO,KAAKV,OAAO,GAAGJ,EAAI,KAAKA,EAAG,KAAKI,OAAO,GAAGH,EAAI,KAAKA,GACzD,IAAA,IAAIc,EAAI,EAAGA,EAAI,KAAKX,OAAOY,OAAQD,IAAK,CACnCE,IAAAA,EAAQ,KAAKb,OAAOW,GAC1BJ,EAAIO,OAAOD,EAAMjB,EAAI,KAAKA,EAAGiB,EAAMhB,EAAI,KAAKA,GAEhDU,EAAIO,OAAO,KAAKd,OAAO,GAAGJ,EAAI,KAAKA,EAAG,KAAKI,OAAO,GAAGH,EAAI,KAAKA,GAC9DU,EAAIQ,YAAc,QAEdR,EAAIS,UADJR,EACgB,MAEA,KAAKP,MAEzBM,EAAIU,SACJV,EAAIW,OAEA9C,IACAmC,EAAIQ,YAAc,SAClBR,EAAIY,WAAW,KAAKC,YAAYxB,EAAG,KAAKwB,YAAYvB,EAAG,KAAKuB,YAAYC,MAAO,KAAKD,YAAYE,YAuXvG,CAAA,IAAA,YAnXD,MAAA,WAES,IADCC,IAAAA,EAAQ,GACLZ,EAAI,EAAGA,EAAI,KAAKX,OAAOY,OAAQD,IAAK,CACnCE,IAAAA,EAAQ,KAAKb,OAAOW,GACtBa,OAAJ,EAEIA,EADAb,IAAM,KAAKX,OAAOY,OAAS,EACf,KAAKZ,OAAO,GAEZ,KAAKA,OAAOW,EAAI,GAEhCY,EAAME,KAAK,IAAIjC,EACX,IAAIG,EAAMkB,EAAMjB,EAAI,KAAKA,EAAGiB,EAAMhB,EAAI,KAAKA,GAC3C,IAAIF,EAAM6B,EAAU5B,EAAI,KAAKA,EAAG4B,EAAU3B,EAAI,KAAKA,KAEpD0B,OAAAA,IAqWV,CAAA,IAAA,kBAlWD,MAAA,WACQG,IADU,EACVA,EAAK,KACLC,EAAK,KACLC,EAAK,EACLC,EAAK,EACS,EAAA,EAAA,KAAK7B,QALT,IAKiB,IAAA,EAAA,MAAA,EAAA,EAAA,KAAA,MAAA,CAAtBa,IAAAA,EAAsB,EAAA,OACjB,MAANa,GAAcb,EAAMjB,EAAI8B,KACxBA,EAAKb,EAAMjB,IAEL,MAAN+B,GAAcd,EAAMhB,EAAI8B,KACxBA,EAAKd,EAAMhB,GAEXgB,EAAMjB,EAAIgC,IACVA,EAAKf,EAAMjB,GAEXiB,EAAMhB,EAAIgC,IACVA,EAAKhB,EAAMhB,IAhBL,MAAA,GAAA,EAAA,EAAA,GAAA,QAAA,EAAA,IAqBP,OAAA,IAAIiC,EAAUJ,EAAIC,EAFbC,EAAKF,EACJG,EAAKF,KA8UrB,CAAA,IAAA,oBA1UD,MAAA,WACSP,KAAAA,YAAc,IAAIU,EACnB,KAAK1B,gBAAgBR,EAAI,KAAKA,EAC9B,KAAKQ,gBAAgBP,EAAI,KAAKA,EAC9B,KAAKO,gBAAgBiB,MACrB,KAAKjB,gBAAgBkB,UAqU5B,CAAA,IAAA,WAjUD,MAAA,SAASS,GAEY,IAFL,EAEK,EAAA,EAAA,KAAKC,aAFV,IAEuB,IAAA,EAAA,MAAA,EAAA,EAAA,KAAA,MAAA,CAA1BC,IAA0B,EAA1BA,EAA0B,EAAA,MACTF,EAAAA,EAAAA,EAAMC,aADG,IACU,IAAA,EAAA,MAAA,EAAA,EAAA,KAAA,MAAA,CACjCE,GAAAA,EAAcD,EADmB,EAAA,OAE1B,OAAA,GAHgB,MAAA,GAAA,EAAA,EAAA,GAAA,QAAA,EAAA,MAFvB,MAAA,GAAA,EAAA,EAAA,GAAA,QAAA,EAAA,IAWLE,OAAAA,EAAiB,KAAKf,YAAYgB,OAAQL,EAAMX,iBAsT1D,EA9ZCtB,GA4GAgC,EAAAA,WACUlC,SAAAA,EAAAA,EAAGC,EAAGwB,EAAOC,GAAQ,EAAA,KAAA,GACxB1B,KAAAA,EAAIA,EACJC,KAAAA,EAAIA,EACJwB,KAAAA,MAAQA,EACRC,KAAAA,OAASA,EACTc,KAAAA,OAAS,IAAIzC,EAAM,KAAKC,EAAI,KAAKyB,MAAQ,EAAG,KAAKxB,EAAI,KAAKyB,OAAS,GA4S3E,OAAA,EAAA,EAAA,CAAA,CAAA,IAAA,WAzSD,MAAA,SAASS,GACEM,OAAAA,EAAmB,KAAMN,OAwSnC,EAlTCD,GAcAQ,EAAAA,WACU1C,SAAAA,EAAAA,EAAGC,EAAGwB,EAAOC,GAAQ,EAAA,KAAA,GACxBiB,KAAAA,KAAO,IAAIC,EAAS5C,EAAGC,EAAGwB,EAAOC,GACjCmB,KAAAA,SAAW,EAiSnB,OAAA,EAAA,EAAA,CAAA,CAAA,IAAA,SA9RD,MAAA,SAAOC,GACEC,KAAAA,WAAW,KAAKJ,KAAMG,KA6R9B,CAAA,IAAA,aA1RD,MAAA,SAAWE,EAAMF,GACT,GAACA,EAAMtB,YAAYZ,SAASoC,EAAKxB,aAAjC,CAICwB,EAAKC,OAAOjC,OAAS,KAAK6B,WAAcG,EAAKE,YACzCC,KAAAA,cAAcH,GAGnBI,IAAAA,GAAqB,EACrBJ,EAAKE,aACLE,GAAqB,EACjBN,EAAMtB,YAAYZ,SAASoC,EAAKK,GAAG7B,aAC/BsB,EAAMtB,YAAYZ,SAASoC,EAAKM,GAAG9B,cACnCsB,EAAMtB,YAAYZ,SAASoC,EAAKO,GAAG/B,cACnCsB,EAAMtB,YAAYZ,SAASoC,EAAKQ,GAAGhC,aACnC4B,GAAqB,EAEhBL,KAAAA,WAAWC,EAAKK,GAAIP,GAEtBA,EAAMtB,YAAYZ,SAASoC,EAAKM,GAAG9B,aACtCsB,EAAMtB,YAAYZ,SAASoC,EAAKO,GAAG/B,cACnCsB,EAAMtB,YAAYZ,SAASoC,EAAKQ,GAAGhC,aACnC4B,GAAqB,EAEhBL,KAAAA,WAAWC,EAAKM,GAAIR,GAEtBA,EAAMtB,YAAYZ,SAASoC,EAAKO,GAAG/B,aACtCsB,EAAMtB,YAAYZ,SAASoC,EAAKQ,GAAGhC,aACnC4B,GAAqB,EAEhBL,KAAAA,WAAWC,EAAKO,GAAIT,GAEtBA,EAAMtB,YAAYZ,SAASoC,EAAKQ,GAAGhC,cACrCuB,KAAAA,WAAWC,EAAKQ,GAAIV,IAI7BM,GACAJ,EAAKC,OAAOpB,KAAKiB,MAmPxB,CAAA,IAAA,gBA/OD,MAAA,SAAcE,GACNS,IAAAA,EAAYT,EAAKxB,YAAYC,MAAQ,EACrCiC,EAAaV,EAAKxB,YAAYE,OAAS,EAC3CsB,EAAKK,GAAK,IAAIT,EAASI,EAAKxB,YAAYxB,EAAGgD,EAAKxB,YAAYvB,EAAGwD,EAAWC,GAC1EV,EAAKM,GAAK,IAAIV,EAASI,EAAKxB,YAAYxB,EAAIyD,EAAWT,EAAKxB,YAAYvB,EAAGwD,EAAWC,GACtFV,EAAKO,GAAK,IAAIX,EAASI,EAAKxB,YAAYxB,EAAGgD,EAAKxB,YAAYvB,EAAIyD,EAAYD,EAAWC,GACvFV,EAAKQ,GAAK,IAAIZ,EAASI,EAAKxB,YAAYxB,EAAIyD,EAAWT,EAAKxB,YAAYvB,EAAIyD,EAAYD,EAAWC,GACnGV,EAAKE,YAAa,EAEdS,IAAAA,EAAYX,EAAKC,OACrBD,EAAKC,OAAS,GAEIU,IAZF,EAYEA,EAAAA,EAAAA,GAZF,IAYa,IAAA,EAAA,MAAA,EAAA,EAAA,KAAA,MAAA,CAApBb,IAAAA,EAAoB,EAAA,MACpBC,KAAAA,WAAWC,EAAMF,IAbV,MAAA,GAAA,EAAA,EAAA,GAAA,QAAA,EAAA,OA+OnB,CAAA,IAAA,aA9ND,MAAA,SAAWA,GACA,OAAA,KAAKc,eAAe,KAAKjB,KAAMG,KA6NzC,CAAA,IAAA,iBA1ND,MAAA,SAAeE,EAAMa,GACbC,IADyB,EACzBA,EAAa,GACGd,EAAAA,EAAAA,EAAKC,QAFI,IAEI,IAAA,EAAA,MAAA,EAAA,EAAA,KAAA,MAAA,CAAtBH,IAAAA,EAAsB,EAAA,MACzBe,EAAW1D,KAAO2C,EAAM3C,KAGxB0D,EAAWjD,SAASkC,IACpBgB,EAAWjC,KAAKiB,KAPK,MAAA,GAAA,EAAA,EAAA,GAAA,QAAA,EAAA,IAyBtBgB,OAdHd,EAAKE,aACDW,EAAWrC,YAAYZ,SAASoC,EAAKK,GAAG7B,eACxCsC,EAAaA,EAAWC,OAAO,KAAKH,eAAeZ,EAAKK,GAAIQ,KAE5DA,EAAWrC,YAAYZ,SAASoC,EAAKM,GAAG9B,eACxCsC,EAAaA,EAAWC,OAAO,KAAKH,eAAeZ,EAAKM,GAAIO,KAE5DA,EAAWrC,YAAYZ,SAASoC,EAAKO,GAAG/B,eACxCsC,EAAaA,EAAWC,OAAO,KAAKH,eAAeZ,EAAKO,GAAIM,KAE5DA,EAAWrC,YAAYZ,SAASoC,EAAKQ,GAAGhC,eACxCsC,EAAaA,EAAWC,OAAO,KAAKH,eAAeZ,EAAKQ,GAAIK,MAG7DC,IAiMV,CAAA,IAAA,OA9LD,MAAA,SAAKnD,EAAKqC,GACNrC,EAAIQ,YAAc,QAClBR,EAAIY,WAAWyB,EAAKxB,YAAYxB,EAAGgD,EAAKxB,YAAYvB,EAAG+C,EAAKxB,YAAYC,MAAOuB,EAAKxB,YAAYE,QAC5FsB,EAAKE,aACAc,KAAAA,KAAKrD,EAAKqC,EAAKK,IACfW,KAAAA,KAAKrD,EAAKqC,EAAKM,IACfU,KAAAA,KAAKrD,EAAKqC,EAAKO,IACfS,KAAAA,KAAKrD,EAAKqC,EAAKQ,SAuL3B,EApSCd,GAkHAE,EACF,SAAY5C,EAAAA,EAAGC,EAAGwB,EAAOC,GAAQ,EAAA,KAAA,GACxBuB,KAAAA,OAAS,GACTzB,KAAAA,YAAc,IAAIU,EAAUlC,EAAGC,EAAGwB,EAAOC,GACzC2B,KAAAA,GAAK,KACLC,KAAAA,GAAK,KACLC,KAAAA,GAAK,KACLC,KAAAA,GAAK,KACLN,KAAAA,YAAa,GAM1B,SAASe,EAAUC,EAAGC,EAAGC,GACdD,OAAAA,EAAEnE,GAAKqE,KAAKC,IAAIJ,EAAElE,EAAGoE,EAAEpE,IAC1BmE,EAAEnE,GAAKqE,KAAKE,IAAIL,EAAElE,EAAGoE,EAAEpE,IACvBmE,EAAElE,GAAKoE,KAAKC,IAAIJ,EAAEjE,EAAGmE,EAAEnE,IACvBkE,EAAElE,GAAKoE,KAAKE,IAAIL,EAAEjE,EAAGmE,EAAEnE,GAQ/B,SAASuE,EAAYN,EAAGC,EAAGC,GACjBK,IAAAA,GAAKN,EAAElE,EAAIiE,EAAEjE,IAAMmE,EAAEpE,EAAImE,EAAEnE,IAC5BmE,EAAEnE,EAAIkE,EAAElE,IAAMoE,EAAEnE,EAAIkE,EAAElE,GACvBwE,OAAAA,EAAI,EACG,EACAA,EAAI,EACJ,EAEA,EAIf,SAASnC,EAAcoC,EAAIC,GACjBC,IAAAA,EAAKJ,EAAYE,EAAG7E,GAAI6E,EAAG5E,GAAI6E,EAAG9E,IAClCgF,EAAKL,EAAYE,EAAG7E,GAAI6E,EAAG5E,GAAI6E,EAAG7E,IAClCgF,EAAKN,EAAYG,EAAG9E,GAAI8E,EAAG7E,GAAI4E,EAAG7E,IAClCkF,EAAKP,EAAYG,EAAG9E,GAAI8E,EAAG7E,GAAI4E,EAAG5E,IACpC8E,OAAAA,IAAOC,GAAMC,IAAOC,MAIb,IAAPH,IAAYX,EAAUS,EAAG7E,GAAI8E,EAAG9E,GAAI6E,EAAG5E,SAKhC,IAAP+E,IAAYZ,EAAUS,EAAG7E,GAAI8E,EAAG7E,GAAI4E,EAAG5E,SAKhC,IAAPgF,IAAYb,EAAUU,EAAG9E,GAAI6E,EAAG7E,GAAI8E,EAAG7E,MAK7B,IAAPiF,GAAYd,EAAUU,EAAG9E,GAAI6E,EAAG5E,GAAI6E,EAAG7E,OAGlD,SAAS2C,EAAmBuC,EAAIC,GACrBD,OAAAA,EAAGhF,EAAIiF,EAAGjF,EAAIiF,EAAGxD,OACpBuD,EAAGhF,EAAIgF,EAAGvD,MAAQwD,EAAGjF,GACrBgF,EAAG/E,EAAIgF,EAAGhF,EAAIgF,EAAGvD,QACjBsD,EAAG/E,EAAI+E,EAAGtD,OAASuD,EAAGhF,EAG9B,SAASsC,EAAiB2B,EAAGE,GAClBF,OAAAA,EAAElE,EAAIoE,EAAEpE,GACXkE,EAAElE,EAAIoE,EAAEpE,EAAIoE,EAAE3C,OACdyC,EAAEjE,EAAImE,EAAEnE,GACRiE,EAAEjE,EAAImE,EAAEnE,EAAImE,EAAE1C,OAGtB,IAAMwD,EAAStG,SAASC,eAAe,UACjC8B,EAAMuE,EAAOC,WAAW,MACxB1D,EAAQ,IACRC,EAAS,IAEXuB,EAAS,GAEb,SAASxD,IACLwD,EAAS,GAEJ,IADCmC,IAAAA,EAAS,CAAC,OAAQ,SAAU,OAAQ,SAAU,QAAS,SACpDrE,EAAI,EAAGA,EAAI7C,EAAgB6C,IAAK,CAEhC,IADDX,IAAAA,EAAS,GACJiF,EAAI,EAAGA,EAAIhB,KAAKiB,MAAMjB,KAAKkB,SAAWnH,GAAsBD,EAAkBkH,IACnFjF,EAAOyB,KAAK,IAAI9B,EACZsE,KAAKkB,SAAWlH,EAChBgG,KAAKkB,SAAWjH,IAGxB2E,EAAOpB,KACH,IAAI3B,EAAMa,EAAGX,EACO,IAAhBiE,KAAKkB,SACW,IAAhBlB,KAAKkB,SACLH,EAAOf,KAAKmB,MAAMnB,KAAKkB,SAAWH,EAAOpE,YAMzD,SAASgD,IACLrD,EAAIS,UAAY,QAChBT,EAAI8E,SAAS,EAAG,EAAGhE,EAAOC,GACpBgE,IAHM,EAGNA,EAAW,IAAIhD,EAAS,EAAG,EAAGjB,EAAOC,GACzBuB,EAAAA,EAAAA,GAJN,IAIc,IAAA,EAAA,MAAA,EAAA,EAAA,KAAA,MAAA,CAAjBH,IAAAA,EAAiB,EAAA,MACtBA,EAAMpC,oBACNgF,EAASC,OAAO7C,IANR,MAAA,GAAA,EAAA,EAAA,GAAA,QAAA,EAAA,IASRvE,GACAmH,EAAS1B,KAAKrD,EAAK+E,EAAS/C,MAG1BiD,IAbM,EAaNA,EAAe,IAAIC,IACP5C,EAAAA,EAAAA,GAdN,IAcc,IAAA,EAAA,MAAA,EAAA,EAAA,KAAA,MAAA,CAAjBH,IAAAA,EAAiB,EAAA,MAClB8C,IAAAA,EAAaE,IAAIhD,EAAM3C,IAAvByF,CAGA9B,IAJkB,EAIlBA,EAAa4B,EAAS5B,WAAWhB,GACfgB,EAAAA,EAAAA,GALA,IAKY,IAAA,EAAA,MAAA,EAAA,EAAA,KAAA,MAAA,CAAzBiC,IAAAA,EAAyB,EAAA,MAC9BH,EAAaI,IAAID,EAAU5F,KANT,MAAA,GAAA,EAAA,EAAA,GAAA,QAAA,EAAA,IAQlB2D,EAAW9C,OAAS,GACpB4E,EAAaI,IAAIlD,EAAM3C,MAvBnB,MAAA,GAAA,EAAA,EAAA,GAAA,QAAA,EAAA,IA2BM8C,IA3BN,EA2BMA,EAAAA,EAAAA,GA3BN,IA2Bc,IAAA,EAAA,MAAA,EAAA,EAAA,KAAA,MAAA,CAAjBH,IAAAA,EAAiB,EAAA,MAClB8C,EAAaE,IAAIhD,EAAM3C,IACvB2C,EAAMkB,KAAKrD,GAAK,GAEhBmC,EAAMkB,KAAKrD,IA/BP,MAAA,GAAA,EAAA,EAAA,GAAA,QAAA,EAAA,KAoChB,SAASsF,IACahD,IADN,EACMA,EAAAA,EAAAA,GADN,IACc,IAAA,EAAA,MAAA,EAAA,EAAA,KAAA,MAAA,CAAjBH,IAAAA,EAAiB,EAAA,MACtBA,EAAMxC,MAAgC,GAAvB+D,KAAKkB,SAAW,IAC/BzC,EAAMvC,MAAgC,GAAvB8D,KAAKkB,SAAW,IAC/BzC,EAAM9C,GAAK8C,EAAMxC,KACjBwC,EAAM7C,GAAK6C,EAAMvC,KACbuC,EAAM9C,EAAI,IACV8C,EAAM9C,EAAI,EACV8C,EAAMxC,KAAO,GAEbwC,EAAM7C,EAAI,IACV6C,EAAM7C,EAAI,EACV6C,EAAMvC,KAAO,GAEbuC,EAAM9C,EAAIyB,IACVqB,EAAM9C,EAAIyB,EACVqB,EAAMxC,KAAO,GAEbwC,EAAM7C,EAAIyB,IACVoB,EAAM7C,EAAIyB,EACVoB,EAAMvC,KAAO,IApBT,MAAA,GAAA,EAAA,EAAA,GAAA,QAAA,EAAA,KAyBhB,SAAS2F,IACLzG,IACAuE,IAEAmC,YAAY,WACRF,IACAjC,KACD,IAGPkC","file":"app.b7e61727.js","sourceRoot":"..","sourcesContent":["let numberOfShapes = 50;\nlet minNumberOfSides = 3;\nlet sideNumberVarience = 5;\nlet maxShapeWidth = 200;\nlet maxShapeHeight = 200;\nlet drawQuadTree = false;\nlet drawBoundingBoxes = false;\nlet hideColliding = false;\nlet hideNonColliding = false;\n\nconst numberOfShapesElement = document.getElementById(\"numberOfShapes\");\nconst minNumberOfSidesElement = document.getElementById(\"minNumberOfSides\");\nconst sideNumberVarienceElement = document.getElementById(\"sideNumberVarience\");\nconst maxShapeWidthElement = document.getElementById(\"maxShapeWidth\");\nconst maxShapeHeightElement = document.getElementById(\"maxShapeHeight\");\nconst drawQuadTreeElement = document.getElementById(\"drawQuadTree\");\nconst drawBoundingBoxesElement = document.getElementById(\"drawBoundingBoxes\");\nconst hideCollidingElement = document.getElementById(\"hideColliding\");\nconst hideNonCollidingElement = document.getElementById(\"hideNonColliding\");\n\nnumberOfShapesElement.value = numberOfShapes;\nnumberOfShapesElement.oninput(null);\nminNumberOfSidesElement.value = minNumberOfSides;\nminNumberOfSidesElement.oninput(null);\nsideNumberVarienceElement.value = sideNumberVarience;\nsideNumberVarienceElement.oninput(null);\nmaxShapeWidthElement.value = maxShapeWidth;\nmaxShapeWidthElement.oninput(null);\nmaxShapeHeightElement.value = maxShapeHeight;\nmaxShapeHeightElement.oninput(null);\n\nnumberOfShapesElement.onchange = function () {\n    numberOfShapes = numberOfShapesElement.value;\n    generateShapes();\n}\nminNumberOfSidesElement.onchange = function () {\n    minNumberOfSides = minNumberOfSidesElement.value;\n    generateShapes();\n}\nsideNumberVarienceElement.onchange = function () {\n    sideNumberVarience = sideNumberVarienceElement.value;\n    generateShapes();\n}\nmaxShapeWidthElement.onchange = function () {\n    maxShapeWidth = maxShapeWidthElement.value;\n    generateShapes();\n}\nmaxShapeHeightElement.onchange = function () {\n    maxShapeHeight = maxShapeHeightElement.value;\n    generateShapes();\n}\ndrawQuadTreeElement.onclick = function () {\n    drawQuadTree = drawQuadTreeElement.checked;\n}\ndrawBoundingBoxesElement.onclick = function () {\n    drawBoundingBoxes = drawBoundingBoxesElement.checked;\n}\nhideCollidingElement.onclick = function () {\n    hideColliding = hideCollidingElement.checked;\n}\nhideNonCollidingElement.onclick = function () {\n    hideNonColliding = hideNonCollidingElement.checked;\n}\n\nclass Line {\n    constructor(p1, p2) {\n        this.p1 = p1;\n        this.p2 = p2;\n    }\n}\n\nclass Point {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n}\n\nclass Shape {\n    constructor(id, points, x, y, color) {\n        this.id = id;\n        this.points = points;\n        this.x = x;\n        this.y = y;\n        this.color = color;\n        this.xVel = 0;\n        this.yVel = 0;\n        this.baseBoundingBox = this.calcBoundingBox();\n        this.recalcBoundingBox();\n    }\n\n    draw(ctx, collides) {\n        if (collides && hideColliding) {\n            return;\n        }\n        if (!collides && hideNonColliding) {\n            return;\n        }\n\n        ctx.beginPath();\n        ctx.moveTo(this.points[0].x + this.x, this.points[0].y + this.y);\n        for (let i = 1; i < this.points.length; i++) {\n            const point = this.points[i];\n            ctx.lineTo(point.x + this.x, point.y + this.y);\n        }\n        ctx.lineTo(this.points[0].x + this.x, this.points[0].y + this.y);\n        ctx.strokeStyle = 'black';\n        if (collides) {\n            ctx.fillStyle = 'red';\n        } else {\n            ctx.fillStyle = this.color;\n        }\n        ctx.stroke();\n        ctx.fill();\n\n        if (drawBoundingBoxes) {\n            ctx.strokeStyle = 'purple';\n            ctx.strokeRect(this.boundingBox.x, this.boundingBox.y, this.boundingBox.width, this.boundingBox.height);\n        }\n    }\n\n    calcLines() {\n        const lines = [];\n        for (let i = 0; i < this.points.length; i++) {\n            const point = this.points[i];\n            let nextPoint;\n            if (i === this.points.length - 1) {\n                nextPoint = this.points[0];\n            } else {\n                nextPoint = this.points[i + 1];\n            }\n            lines.push(new Line(\n                new Point(point.x + this.x, point.y + this.y),\n                new Point(nextPoint.x + this.x, nextPoint.y + this.y)));\n        }\n        return lines;\n    }\n\n    calcBoundingBox() {\n        let x1 = null;\n        let y1 = null;\n        let x2 = 0;\n        let y2 = 0;\n        for (let point of this.points) {\n            if (x1 == null || point.x < x1) {\n                x1 = point.x;\n            }\n            if (y1 == null || point.y < y1) {\n                y1 = point.y;\n            }\n            if (point.x > x2) {\n                x2 = point.x;\n            }\n            if (point.y > y2) {\n                y2 = point.y;\n            }\n        }\n        let width = x2 - x1;\n        let height = y2 - y1;\n        return new Rectangle(x1, y1, width, height);\n    }\n\n    recalcBoundingBox() {\n        this.boundingBox = new Rectangle(\n            this.baseBoundingBox.x + this.x,\n            this.baseBoundingBox.y + this.y,\n            this.baseBoundingBox.width,\n            this.baseBoundingBox.height,\n        );\n    }\n\n    collides(other) {\n        // To test intersection, we first check every edge against each other\n        for (let line of this.calcLines()) {\n            for (let otherLine of other.calcLines()) {\n                if (lineCollision(line, otherLine)) {\n                    return true;\n                }\n            }\n        }\n\n        // Then, to test the complete containment edge case, we check to see if center point is in bounding box of other\n        return pointInRectangle(this.boundingBox.center, other.boundingBox);\n    }\n}\n\nclass Rectangle {\n    constructor(x, y, width, height) {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n        this.center = new Point(this.x + this.width / 2, this.y + this.height / 2);\n    }\n\n    collides(other) {\n        return rectangleCollision(this, other);\n    }\n}\n\nclass QuadTree {\n    constructor(x, y, width, height) {\n        this.root = new QuadNode(x, y, width, height);\n        this.capacity = 1;\n    }\n\n    insert(shape) {\n        this.insertInto(this.root, shape);\n    }\n\n    insertInto(node, shape) {\n        if (!shape.boundingBox.collides(node.boundingBox)) {\n            return;\n        }\n\n        if ((node.shapes.length > this.capacity) && !node.subdivided) {\n            this.subdivideNode(node);\n        }\n\n        let insertIntoThisNode = true;\n        if (node.subdivided) {\n            insertIntoThisNode = false;\n            if (shape.boundingBox.collides(node.nw.boundingBox)) {\n                if (shape.boundingBox.collides(node.ne.boundingBox) ||\n                    shape.boundingBox.collides(node.sw.boundingBox) ||\n                    shape.boundingBox.collides(node.se.boundingBox)) {\n                    insertIntoThisNode = true;\n                } else {\n                    this.insertInto(node.nw, shape);\n                }\n            } else if (shape.boundingBox.collides(node.ne.boundingBox)) {\n                if (shape.boundingBox.collides(node.sw.boundingBox) ||\n                    shape.boundingBox.collides(node.se.boundingBox)) {\n                    insertIntoThisNode = true;\n                } else {\n                    this.insertInto(node.ne, shape);\n                }\n            } else if (shape.boundingBox.collides(node.sw.boundingBox)) {\n                if (shape.boundingBox.collides(node.se.boundingBox)) {\n                    insertIntoThisNode = true;\n                } else {\n                    this.insertInto(node.sw, shape);\n                }\n            } else if (shape.boundingBox.collides(node.se.boundingBox)) {\n                this.insertInto(node.se, shape);\n            }\n        }\n\n        if (insertIntoThisNode) {\n            node.shapes.push(shape);\n        }\n    }\n\n    subdivideNode(node) {\n        let halfWidth = node.boundingBox.width / 2;\n        let halfHeight = node.boundingBox.height / 2;\n        node.nw = new QuadNode(node.boundingBox.x, node.boundingBox.y, halfWidth, halfHeight);\n        node.ne = new QuadNode(node.boundingBox.x + halfWidth, node.boundingBox.y, halfWidth, halfHeight);\n        node.sw = new QuadNode(node.boundingBox.x, node.boundingBox.y + halfHeight, halfWidth, halfHeight);\n        node.se = new QuadNode(node.boundingBox.x + halfWidth, node.boundingBox.y + halfHeight, halfWidth, halfHeight);\n        node.subdivided = true;\n\n        let oldShapes = node.shapes;\n        node.shapes = [];\n\n        for (let shape of oldShapes) {\n            this.insertInto(node, shape);\n        }\n    }\n\n    collisions(shape) {\n        return this.collisionsFrom(this.root, shape);\n    }\n\n    collisionsFrom(node, queryShape) {\n        let collisions = [];\n        for (const shape of node.shapes) {\n            if (queryShape.id === shape.id) {\n                continue;\n            }\n            if (queryShape.collides(shape)) {\n                collisions.push(shape);\n            }\n        }\n\n        if (node.subdivided) {\n            if (queryShape.boundingBox.collides(node.nw.boundingBox)) {\n                collisions = collisions.concat(this.collisionsFrom(node.nw, queryShape));\n            }\n            if (queryShape.boundingBox.collides(node.ne.boundingBox)) {\n                collisions = collisions.concat(this.collisionsFrom(node.ne, queryShape));\n            }\n            if (queryShape.boundingBox.collides(node.sw.boundingBox)) {\n                collisions = collisions.concat(this.collisionsFrom(node.sw, queryShape));\n            }\n            if (queryShape.boundingBox.collides(node.se.boundingBox)) {\n                collisions = collisions.concat(this.collisionsFrom(node.se, queryShape));\n            }\n        }\n        return collisions;\n    }\n\n    draw(ctx, node) {\n        ctx.strokeStyle = 'black';\n        ctx.strokeRect(node.boundingBox.x, node.boundingBox.y, node.boundingBox.width, node.boundingBox.height);\n        if (node.subdivided) {\n            this.draw(ctx, node.nw);\n            this.draw(ctx, node.ne);\n            this.draw(ctx, node.sw);\n            this.draw(ctx, node.se);\n        }\n    }\n}\n\nclass QuadNode {\n    constructor(x, y, width, height) {\n        this.shapes = [];\n        this.boundingBox = new Rectangle(x, y, width, height);\n        this.nw = null;\n        this.ne = null;\n        this.sw = null;\n        this.se = null;\n        this.subdivided = false;\n    }\n}\n\n// Given three colinear points p, q, r, the function checks if\n// point q lies on line segment 'pr'\nfunction onSegment(p, q, r) {\n    return q.x <= Math.max(p.x, r.x) &&\n        q.x >= Math.min(p.x, r.x) &&\n        q.y <= Math.max(p.y, r.y) &&\n        q.y >= Math.min(p.y, r.y);\n}\n\n// Finds the orientation of an ordered triplet (p,q,r)\n// Returns the following values:\n// 0 : Colinear points\n// 1 : Clockwise points\n// 2 : Counterclockwise\nfunction orientation(p, q, r) {\n    const v = (q.y - p.y) * (r.x - q.x) -\n        (q.x - p.x) * (r.y - q.y);\n    if (v > 0) {\n        return 1;\n    } else if (v < 0) {\n        return 2;\n    } else {\n        return 0;\n    }\n}\n\nfunction lineCollision(l1, l2) {\n    const o1 = orientation(l1.p1, l1.p2, l2.p1);\n    const o2 = orientation(l1.p1, l1.p2, l2.p2);\n    const o3 = orientation(l2.p1, l2.p2, l1.p1);\n    const o4 = orientation(l2.p1, l2.p2, l1.p2);\n    if (o1 !== o2 && o3 !== o4) {\n        return true;\n    }\n    // l1.p1, l1.p2, l2.p1 are colinear and l2.p1 lies on l1.\n    if (o1 === 0 && onSegment(l1.p1, l2.p1, l1.p2)) {\n        return true;\n    }\n\n    // l1.p1, l1.p2, l2.p2 are colinear and l2.p2 lies on l1.\n    if (o2 === 0 && onSegment(l1.p1, l2.p2, l1.p2)) {\n        return true;\n    }\n\n    // l2.p1, l2.p2, l1.p1 are colinear and l1.p1 lies on l2.\n    if (o3 === 0 && onSegment(l2.p1, l1.p1, l2.p2)) {\n        return true;\n    }\n\n    // l2.p1, l2.p2, l1.p2 are colinear and l1.p2 lies on l2.\n    return o4 === 0 && onSegment(l2.p1, l1.p2, l2.p2);\n}\n\nfunction rectangleCollision(r1, r2) {\n    return r1.x < r2.x + r2.width &&\n        r1.x + r1.width > r2.x &&\n        r1.y < r2.y + r2.height &&\n        r1.y + r1.height > r2.y;\n}\n\nfunction pointInRectangle(p, r) {\n    return p.x > r.x &&\n        p.x < r.x + r.width &&\n        p.y > r.y &&\n        p.y < r.y + r.height;\n}\n\nconst canvas = document.getElementById(\"canvas\");\nconst ctx = canvas.getContext(\"2d\");\nconst width = 800;\nconst height = 800;\n\nlet shapes = [];\n\nfunction generateShapes() {\n    shapes = [];\n    const colors = ['blue', 'purple', 'pink', 'orange', 'black', 'green'];\n    for (let i = 0; i < numberOfShapes; i++) {\n        let points = [];\n        for (let j = 0; j < Math.round(Math.random() * sideNumberVarience) + minNumberOfSides; j++) {\n            points.push(new Point(\n                Math.random() * maxShapeWidth,\n                Math.random() * maxShapeHeight,\n            ));\n        }\n        shapes.push(\n            new Shape(i, points,\n                Math.random() * 800,\n                Math.random() * 800,\n                colors[Math.floor(Math.random() * colors.length)])\n        );\n    }\n}\n\n\nfunction draw() {\n    ctx.fillStyle = 'white';\n    ctx.fillRect(0, 0, width, height);\n    const quadtree = new QuadTree(0, 0, width, height);\n    for (let shape of shapes) {\n        shape.recalcBoundingBox();\n        quadtree.insert(shape);\n    }\n\n    if (drawQuadTree) {\n        quadtree.draw(ctx, quadtree.root);\n    }\n\n    const collisionIds = new Set();\n    for (let shape of shapes) {\n        if (collisionIds.has(shape.id)) {\n            continue;\n        }\n        let collisions = quadtree.collisions(shape);\n        for (let collision of collisions) {\n            collisionIds.add(collision.id);\n        }\n        if (collisions.length > 0) {\n            collisionIds.add(shape.id);\n        }\n    }\n\n    for (let shape of shapes) {\n        if (collisionIds.has(shape.id)) {\n            shape.draw(ctx, true);\n        } else {\n            shape.draw(ctx);\n        }\n    }\n}\n\nfunction move() {\n    for (let shape of shapes) {\n        shape.xVel += (Math.random() - 0.5) * 2;\n        shape.yVel += (Math.random() - 0.5) * 2;\n        shape.x += shape.xVel;\n        shape.y += shape.yVel;\n        if (shape.x < 0) {\n            shape.x = 0;\n            shape.xVel = 0;\n        }\n        if (shape.y < 0) {\n            shape.y = 0;\n            shape.yVel = 0;\n        }\n        if (shape.x > width) {\n            shape.x = width;\n            shape.xVel = 0;\n        }\n        if (shape.y > height) {\n            shape.y = height;\n            shape.yVel = 0;\n        }\n    }\n}\n\nfunction start() {\n    generateShapes();\n    draw();\n\n    setInterval(() => {\n        move();\n        draw();\n    }, 50);\n}\n\nstart();\n"]}